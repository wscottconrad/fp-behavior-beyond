
%GratingPatchesAnalysis
% adapted from Robin Haak's script, Scott Conrad July 2025
% major changes: uses fiber photometry data instad of spikes, filters out trials where animal
% is moving 
%
% Robin Haak's original comments below:
%online analysis for 'GratingPatches' using NI stream times
%you need a GPU to run this script!
%Robin Haak, March 2023

%% code behavior
filtMove = true; % true if you want to filter out trials with movement
cBarLim = false; % if you want to limit cbar to 2 std above the median
fiberData = false; % fiber only data, false for animal

%% preprocessing initialization
lowpass_cutoff = 3; %low-pass cut-off in Hz, e.g. 2
filt_steepness = .95; %how steep the filter transition is (0.5-1, default 0.85)
db_atten = 90; %decibel attenuation of filters (default = 60)
sr = 30; % sampling rate (Hz or FPS)
ma = 90*sr; % moving average window, default = 90 seconds
setUp = 30 * sr; % remove everything up to 30 sec before trials begin, get better fitted signal usually 
numChannels = 1; % number of channels you record from
zThresh = 4; % threshold for further trial inspection


ttlPre = 300; % ms before ttl
ttlPost = 800; % ms after ttl
speedThreshold = 10; % average, for wheelturning (0.01 leads to 300-400 nans, 0.05 seems better?)

% trace window
pre = 0.2; % 0.2 seconds before trial start
post = 0.5; % 0.5 seconds after
before = pre*sr; 
after = post*sr; 
traceTiming = -pre:(sr/(before+after)):(post-(sr/(before+after)));
stim_length = post*sr; %stim length in frames 
trimEnd = 5000; % 10000 for normal trials

stimDataPath = '\\vs03.herseninstituut.knaw.nl\VS03-CSF-1\Conrad\Innate_approach\Data_collection\24.35.01\RF mapping\';

if fiberData
    filePath = '\\vs03.herseninstituut.knaw.nl\VS03-CSF-1\Conrad\Innate_approach\Data_collection\24.35.01\2025_07_31_fiberOnly_noGrating\';
    % filePath = '\\vs03.herseninstituut.knaw.nl\VS03-CSF-1\Conrad\Innate_approach\Data_collection\24.35.01\2025_06_12_rfTest_fiberOnly\';
    load(strcat(stimDataPath, '20250731_rf mapping fiber only no gratings_16_04_11_RH_GratingPatches.mat'))
    trial_length = 2 * sr; % seconds converted to frames
    labelsX = -before:6:trial_length;
    animal = "fiber";
    trimStart = 3000; % ms

else
    date = "2025_07_15_";
    animal = "112742";
    trimStart = 30000; % ms, 30000 for normal trials (30 sec)
    filePath = strcat('\\vs03.herseninstituut.knaw.nl\VS03-CSF-1\Conrad\Innate_approach\Data_collection\24.35.01\', date, animal, '\');
    filePattern = strcat(stimDataPath, erase(date, '_'), '_', animal, '_withspeed*.mat'); % withspeed or newSpeed

    % Get a list of matching files
    files = dir(filePattern);

    % Check if at least one match was found
    if ~isempty(files)
        % Load the first matching file
        fullFileName = fullfile(files(1).folder, files(1).name);
        load(fullFileName);
    else
        warning('No files matching pattern found: %s', filePattern);
    end

    trial_length = 3 * sr; % 3 seconds converted to frames
    labelsX = -before+0.5:6:trial_length+0.5;

    
end
% signal = readtable(strcat(filePath, dates{d}, animalIDs{id}, '\', 'Fluorescence.csv'));
signal = readtable(strcat(filePath, 'Fluorescence.csv'));
events = readtable(strcat(filePath, 'Events.csv'));


timestamps = signal{:,1}/1000; % convert from ms to sec, should be 0.0333 seconds but a little drift posible
eventTS = events{:,1}(events{:,3}==0); %0 is ttl on ramp, 1 is off ramp, in ms
if ~fiberData 
    if strcmp(date, "2025_06_17_") || (strcmp(date, "2025_06_18_") && strcmp(animal, "112741"))
        ttlidx = 1;
    elseif (strcmp(date, "2025_06_19_") && strcmp(animal, "111609")) || (strcmp(date, "2025_07_30_") && (strcmp(animal, "111610")|| strcmp(animal, "112741")))
        ttlidx = 2;
    elseif strcmp(date, "2025_07_15_") && (strcmp(animal, "111609") || strcmp(animal, "112742"))
        ttlidx = 4;
    else
        ttlidx = 3;
    end
else 
    ttlidx = 3;
end
% clipStart = round((eventtimestamps(ttlidx,1)-setUp)/(1000/sr)); %where to clip data, in seconds
clipStart = round((eventTS(ttlidx,1)-trimStart)/(1000/sr)); %where to start data, in frames relative to recording start

clipEnd = round(((max((eventTS), [], 'all')+ trimEnd))/(1000/sr)); % in frames
eventTS = round(eventTS(ttlidx:720+ttlidx-1)/(1000/sr))-clipStart; % eventtimestamps(1) is now aligned from clipstart, e.g. 90 frames = 3 seconds 


for ch = 1:numChannels
% ch = 2;

chGreen = signal{clipStart:clipEnd,((2*ch)+2)};
chIsos = signal{clipStart:clipEnd,((2*ch)+1)};

% plot raw data
% figure;
% plot(timestamps(clipStart:clipEnd), chIsos, 'Color', '#7b8be8');
% hold on;
% plot(timestamps(clipStart:clipEnd), chGreen, 'Color', '#64a858');
% hold on;
% plot([(eventTS'+clipStart)/sr; (eventTS'+clipStart)/sr], repmat(ylim',1,length(eventTS'/sr)), '-k');
% hold on;
% plot([(eventTS'+clipStart+stim_length)/sr; (eventTS'+clipStart+stim_length)/sr], ...
%     repmat(ylim',1,length(eventTS')), '-', 'Color', [0.373, 0.373, 0.588]');
% box off;
% title([char(animal) ' Channel ', num2str(ch) ' raw data']);
% % title(['Fiber only. Channel ' num2str(ch) ' raw data'])
% xlabel('Seconds since RWD recording start');
% ylabel('AU');

% 4 lowpassfilter % changed conversion to sr
lp_normDatG = lpFilter(chGreen, sr, lowpass_cutoff,...
    filt_steepness, db_atten);
lp_normDatI = lpFilter(chIsos, sr, lowpass_cutoff,...
    filt_steepness, db_atten);

% 1 fit isosbestic signal to green channel (motion correction). if using controlfit instead of IRLS_dFF, try
% degree higher than 1
[dFoF, ft_iso_signal] = IRLS_dFF(lp_normDatG, lp_normDatI, 3); % suggested constant is 1.4



% plot filtered data % in seconds
% figure;
% % plot(timestamps(clipStart:clipEnd)*sr-clipStart, dFoF)
% plot(timestamps(clipStart:clipEnd), dFoF);
% hold on;
% plot([(eventTS'+clipStart)/sr; (eventTS'+clipStart)/sr], repmat(ylim',1,length(eventTS'/sr)), '-k');
% hold on;
% plot([(eventTS'+clipStart+stim_length)/sr; (eventTS'+clipStart+stim_length)/sr], ...
%     repmat(ylim',1,length(eventTS')), '-', 'Color', [0.373, 0.373, 0.588]');
% box off;
% % title(['Fiber only. Ch' num2str(ch) ' filtered data'])
% xlabel('Seconds (trimmed data)');
% ylabel('dF/F');

%fixing event timestamps to be an indexing double
eventTF = dsearchn(timestamps(clipStart:clipEnd), (eventTS+clipStart)/sr);

%Make traces...original
traces = NaN(length(eventTF), before + trial_length);
tracesRawG = NaN(length(eventTF), before + trial_length);
tracesG = NaN(length(eventTF), before + trial_length);
tracesI = NaN(length(eventTF), before + trial_length);

AUCfitted = NaN(length(eventTF),1);
AUC_G = NaN(length(eventTF),1);
AUC_I = NaN(length(eventTF),1);

% Compute the indices for the window
startIdx = eventTF - before; 
AUCendIdx = eventTF + after-1; 
endIdx = eventTF + trial_length-1; 

% AUC of df/f trial traces
for m = 1:length(eventTF)
    % Extract the window and store it
    % traces(m) = trapz(dFoF(eventtimestamps(m):endIdx(m))); % traces of fitted data
    traces(m,:) = dFoF((startIdx(m):endIdx(m)))'; % traces of fitted data
    tracesRawG(m,:) = chGreen((startIdx(m):endIdx(m)))'; % traces of raw green data
    tracesG(m,:) = ((lp_normDatG(startIdx(m):endIdx(m))-mean(lp_normDatG(startIdx(m):eventTF(m)-1),"all")))/std(lp_normDatG(startIdx(m):eventTF(m)-1),0,"all"); % traces of filtered green signal
    tracesI(m,:) = ((lp_normDatI(startIdx(m):endIdx(m))-mean(lp_normDatI(startIdx(m):eventTF(m)-1),"all")))/std(lp_normDatI(startIdx(m):eventTF(m)-1),0,"all"); % traces of filtered isosbestic

    % AUCfitted(m) = trapz(dFoF(round(eventtimestamps(m):AUCendIdx(m)))); 
    AUCfitted(m) = trapz(((dFoF(eventTF(m):AUCendIdx(m))-mean(dFoF(startIdx(m):eventTF(m)-1),"all"))/std(dFoF(startIdx(m):eventTF(m)-1),0,"all")));
    AUC_G(m) = trapz(((lp_normDatG(eventTF(m):AUCendIdx(m))-mean(lp_normDatG(startIdx(m):eventTF(m)-1),"all"))/std(lp_normDatG(startIdx(m):eventTF(m)-1),0,"all"))); 
    AUC_I(m) = trapz(((lp_normDatI(eventTF(m):AUCendIdx(m))-mean(lp_normDatI(startIdx(m):eventTF(m)-1),"all"))/std(lp_normDatI(startIdx(m):eventTF(m)-1),0,"all"))); 

end


% % debugging plots, for fiber
% sigTrace = traces((mean(traces(:,6:21),2)>0.005),:); % off by 6-10 frames
% figure; plot(1:66,sigTrace); xline(6);



%% get movement data
if ~fiberData
    speed = structEP.speed;
    dt = datetime(structEP.speedTS, 'InputFormat', 'HH:mm:ss.SSS');
    timeMillis = milliseconds(dt - dt(1)); % speed ms since recording start
    prespeed = 300; %ms beofre first ttl
    alnmnt = eventTF(1)-prespeed/sr+1; % used to align data from rwd ts to running wheel ts
    % sampling rate is not consistant
    % 0 is stim computer recording start

    dtTTL = datetime(structEP.ttlTimes, 'InputFormat', 'HH:mm:ss.SSS');
    ttlMillis = milliseconds(dtTTL - dt(1)); % ttl ms from recording start

    [dif,speedclip] = min(abs(timeMillis-(ttlMillis(1)-prespeed))); % gives index of closest speed ts to whatever 1st ttl - prespeed is to align data
    fprintf('first ttl -300 ms is offset from speed data by %d ms\n', dif)

    timeMillis = timeMillis - timeMillis(speedclip); % now where timeMillis = 0 is 300 ms before 1st ttl
    speedSet = [timeMillis(speedclip:end)', abs(speed(speedclip:end)')];

    % [RS_speed, RS_time] = resample(speed', timeMillis'/1000, 30, 3 ,1);
    % interpolate seems to be a more faithful representation, resample
    % introduced gaussian(?)-looking artifacts

    int_time = min(timeMillis)/1000:1/sr:max(timeMillis)/1000; % interpolate at fp sampling rate
    int_speed = interp1(timeMillis'/1000,speed', int_time, 'pchip');
    flt_speed = abs(lpFilter(int_speed, sr, lowpass_cutoff,...
        filt_steepness, db_atten));

    velocity = flt_speed';
    fluorescence = dFoF(alnmnt+10:length(flt_speed)+alnmnt-1+10);
    % % velocity = zscore(flt_speed)';
    % % fluorescence = zscore(dFoF(alnmnt:length(flt_speed)+alnmnt-1));
    % 
    % % figure;
    % % plot(timeMillis'/1000, speed','.-')
    % % % plot(timeMillis'/1000, speed','-', int_time, flt_speed, '.-')
    % % hold on;
    % % plot([ttlMillis/1000; ttlMillis/1000], repmat(ylim',1,length(ttlMillis)), '-k')
    % 
    % % IRLS
    % % [dFoF_mov, residuals] = IRLS_dFF(zscore(dFoF(alnmnt:length(flt_speed)+890)), zscore(flt_speed'), 1.4);
    % 
    % % autoregressive (lagged) model
    % % nLags = 90; % Adjust based on how long the decay lasts (in samples)
    % % X = zeros(length(velocity) - nLags, nLags);
    % %
    % % for i = 1:nLags
    % %     X(:, i) = velocity(i:end - nLags + i - 1);
    % % end
    % %
    % % y = fluorescence(nLags+1:end);
    % %
    % % % Optional: z-score X and y
    % % % X = zscore(X);
    % % % y = zscore(y);
    % %
    % % % Robust regression
    % % [b, stats] = robustfit(X, y);
    % % predicted = [ones(size(X,1),1), X] * b;
    % % residuals = y - predicted;
    % 
    % % convolution (exp decay)
    % % tau = 3; % Decay constant in seconds (adjust as needed)
    % % t = 0:1/sr:5; % 5 sec window
    % % kernel = exp(-t / tau);
    % %
    % % % Convolve velocity with decay kernel
    % % x_conv = conv(velocity, kernel, 'same');
    % %
    % % % Now regress fluorescence on this convolved signal
    % % [b, stats] = robustfit(x_conv(:), fluorescence(:));
    % % predicted = b(1) + b(2)*x_conv;
    % % residuals = fluorescence - predicted;
    % 
    % % GLM or neural network %% what about laplace (double exponent
    % % distribution? not yet tested %%
    % 
    % basis_duration = 5;     % Window to capture past influence (in seconds)
    % n_basis = 10;           % Number of basis functions
    % n_lags = sr * basis_duration;  % Number of lags (timepoints)
    % 
    % basis = createRaisedCosineBasis(n_lags, n_basis);  % n_lags x n_basis matrix
    % 
    % T = length(velocity);
    % X = zeros(T - n_lags, n_basis);
    % 
    % for t = n_lags+1:T
    %     segment = velocity(t - n_lags:t - 1);  % past window
    %     X(t - n_lags, :) = segment' * basis;   % projection onto each basis
    % end
    % 
    % y = fluorescence(n_lags+1:end);
    % 
    % % non linear (sigmoid/log)
    % % Sigmoid transformation
    % % X = 1 ./ (1 + exp(-X));  % element-wise sigmoid
    % 
    % % OR Log transform (shift to avoid log(0))
    % minX = min(X(:));
    % if minX <= 0
    %     shift = abs(minX) + eps;  % eps = machine precision buffer
    %     X = log(X + shift);
    % end
    % % X = log(X + 1e-3);  % Only valid if all values > -1e-3
    % 
    % [b, stats] = robustfit(X, y);  % Robust regression
    % 
    % y_pred = [ones(size(X,1), 1), X] * b; % glm
    % 
    % % linear
    % % [b, stats] = robustfit(X, y);  % includes intercept term
    % % y_pred = [ones(size(X, 1), 1), X] * b;
    % 
    % % neural network
    % % model = fitrnet(X, y, ...
    % %     'Standardize', true, ...
    % %     'LayerSizes', [10,10], ...     % 2 hidden layer with 10 neurons ea
    % %     'Activations', 'relu', ...  % Or try 'tanh', 'relu', 'sigmoid'
    % %     'Verbose', 1);
    % % y_pred = predict(model, X);
    % 
    % residuals = y - y_pred;
    % 
    % % Estimated temporal kernel (glm)
    % % estimated_kernel = basis * b(2:end);  % exclude intercept
    % % time = (0:n_lags - 1) / fs;
    % 
    % % OLSR
    % % fluorescence = zscore(dFoF(alnmnt:length(flt_speed)+alnmnt-1));
    % % velocity = zscore(flt_speed');
    % % % Add constant (intercept) term
    % % X = [ones(size(velocity)) velocity];    % [n x 2]
    % %
    % % % Perform OLS regression
    % % beta = X \ fluorescence;                % [2 x m] coefficients
    % %
    % % % Predict movement-related component
    % % movement_signal = X * beta;             % [n x m]
    % %
    % % % Subtract predicted movement component to get residuals
    % % residuals = fluorescence - movement_signal;
    % 
    % %polynomial regression
    % % p = polyfit(velocity, fluorescence, 2);  % or try 3, 4, etc.
    % % predicted = polyval(p, velocity);
    % %
    % % % Residuals (fluorescence with movement regressed out)
    % % residuals = fluorescence - predicted;
    % 
    % % lowess
    % % predicted = smooth(velocity, fluorescence, 0.1, 'lowess');  % 0.1 is smoothing span
    % %
    % % residuals = fluorescence - predicted;
    % 
    % % Spline fitting
    % % pp = fit(velocity(:), fluorescence(:), 'smoothingspline');
    % % predicted = pp(velocity);
    % % residuals = fluorescence - predicted;

    ts = timestamps*1000;
    figure;
    plot(int_time'*1000, velocity);
    hold on;
    plot(ts(1:length(fluorescence)), fluorescence);
    hold on;
    % plot(int_time(n_lags+1:end)'*1000, residuals)
    % hold on;
    % plot(int_time(n_lags+1:end)'*1000, y_pred)
    % hold on;
    % plot([ttlMillis; ttlMillis], repmat(ylim',1,length(ttlMillis)), '-r')
    plot([(eventTS'-alnmnt)*1000/sr; (eventTS'-alnmnt)*1000/sr], repmat(ylim',1,length(eventTS')), '-k');
    hold on;
    plot([(eventTS'-alnmnt+stim_length)*1000/sr; (eventTS'-alnmnt+stim_length)*1000/sr], ...
        repmat(ylim',1,length(eventTS')), '-', 'Color', [0.373, 0.373, 0.588]');
    title([animal, 'Ch', ch, ' filtered absolute wheel speed', 'vs dFoF']);



    %% filter ttls where animal moves
    init_prob = zeros(length(eventTF),1); % movement initiation probability
    move_resp = zeros(length(eventTF),1); % if increase in movement

    ttlPre_speed = 1000; % in ms
    ttlPost_speed = 500; % could be interesting to look at offset too
    speedThreshold_init = 0.0025; % play around with this

    direction = structEP.vecDirection;

    if filtMove
        for i = 1:720

            [~,Pre_idx]=min(abs(timeMillis-(ttlMillis(i)-ttlPre)));
            [~,Post_idx]=min(abs(timeMillis-(ttlMillis(i)+ttlPost)));
            [~,ttl_idx]=min(abs(timeMillis-ttlMillis(i)));


            if mean(speedSet(Pre_idx:Post_idx,2)>speedThreshold) %is average thebest? maybe if any point gets above a certain value?
                traces(i,:) = NaN;
                tracesRawG(i,:) = NaN;
                tracesG(i,:) = NaN;
                tracesI(i,:) = NaN;

                AUCfitted(i) = NaN;
                AUC_G(i) = NaN;
                AUC_I(i) = NaN;
            end
            
            % for movement initiation 
        
            [~,Pre_idx]=min(abs(timeMillis-(ttlMillis(i)-ttlPre_speed)));
            [~,Post_idx]=min(abs(timeMillis-(ttlMillis(i)+ttlPost_speed)));

            if (all(speedSet(Pre_idx:ttl_idx,2)<speedThreshold_init) && ...
                    any(speedSet(ttl_idx:Post_idx,2)>speedThreshold_init) && ...
                    i ~= 1) % need to fix this

                init_prob(i) = 1;

            end

            if mean(speedSet(Pre_idx:ttl_idx,2)) < mean(speedSet(ttl_idx:Post_idx,2))

                move_resp(i) = 1;
                dir_move_resp(direction(i)/90)

            end 

        end
    end

end 

%% get grid data
vecUniqueRects = unique(structEP.vecDstRect','rows'); %unique dst rects
vecUniqueStims = 1:length(vecUniqueRects);
vecStimIdx = zeros(size(structEP.vecDstRect,2),1);
for intStim = 1:length(vecUniqueRects)
    vecStimIdx(ismember(structEP.vecDstRect',vecUniqueRects(intStim,:),'rows')) = vecUniqueStims(intStim);
end

vecX_pix = unique(vecUniqueRects(:,1))+(vecUniqueRects(1,3)-unique(vecUniqueRects(1,1)))/2;
vecY_pix = unique(vecUniqueRects(:,2))+(vecUniqueRects(1,4)-unique(vecUniqueRects(1,2)))/2;



%% loop through data
% debugging
weird1 = 0; % for trials with abnormal baseline period after z-scoring, and are just one trial
weirdS = 0; % same as before but more than one trial
cntrl = 0; % normal baseline but also only one trial


% Get logical index of valid (non-NaN) trials
validTrials = ~isnan(AUCfitted);  

% Filter vecStimIdx and traces for valid trials only
vecStimIdx_valid = vecStimIdx(validTrials);
AUCtraces_valid = AUCfitted(validTrials);
traces_valid = traces(validTrials,:);
RawGValid = tracesRawG(validTrials,:);

trialsSD = std(traces_valid(:,1:pre*sr),0,"all"); % try this way
% trialsSD = std(RawGValid(:,1:pre*sr),0,"all"); % try this way


% matAvgRespAll = NaN(length(vecY_pix)*length(vecX_pix),length(traces(1,:)));

AUCmatAvgRespAll = NaN(numel(vecY_pix),numel(vecX_pix),1);
vecAUC = AUCtraces_valid;

matAvgResp = NaN(length(vecY_pix)*length(vecX_pix), length(traces(1,:)));
AUCmatAvgResp = NaN(numel(vecY_pix), numel(vecX_pix));
init_prob_screen = zeros(numel(vecY_pix), numel(vecX_pix));
speed_resp_screen = zeros(numel(vecY_pix), numel(vecX_pix));



XYvector = [vecUniqueRects(:,1) vecUniqueRects(:,2)];

for intLoc = vecUniqueStims
    % z-scoring for traces:
    
    % trials = RawGValid(vecStimIdx_valid == intLoc,:);
    trials = traces_valid(vecStimIdx_valid == intLoc,:);
    if size(trials, 1) ==0
        fprintf("all trials have been filtered out :(")
        intLoc
        XYvector(intLoc,:)
    end 

    % trialsSD = std(trials(:,1:pre*sr),0,"all"); % across trials

    % matAvgResp(intLoc, :) = mean((trials -
    % mean(trials(:,1:pre*sr),2))./trialsSD); % pertrial
    
    matAvgResp(intLoc, :) = mean((trials - mean(trials(:,1:pre*sr),2))/trialsSD); 

    if  mean(matAvgResp(intLoc, before:stim_length+before), "all") > zThresh
        figure;
        plot(1:length(matAvgResp(intLoc, :)), trials - mean(trials(:,1:pre*sr),2));
        hold on;
        legend();
        xline(before, '--k'); hold on;
        xline(before+after, '--r'); hold on;
        title(["intloc = " intLoc, XYvector(intLoc,:) ...
            "Baseline subtracted Trials"]);
        
    end 


    % looking for single trial per stim
    % if abs(matAvgResp(intLoc, 1:pre*sr)) > 2 % find weird trials
    %     intLoc
    %     if size(trials,1) == 1
    %         weird1 = weird1 + 1;
    %     else 
    %         weirdS = weirdS + 1;
    %     end 
    % 
    % elseif size(trials,1) ==1
    %     cntrl = cntrl +1;
    % end

    % if max(mean((trials - mean(trials(:,1:pre*sr),2))./trialsSD), [], "all") >= 30
    %     max(mean((trials - mean(trials(:,1:pre*sr),2))./trialsSD), [], "all")
    %     intLoc
    % end 
    %AUC: 
    AUCmatAvgResp(intLoc) = mean(vecAUC(vecStimIdx_valid == intLoc));
    init_prob_screen(intLoc) = sum(init_prob(vecStimIdx == intLoc));
    speed_resp_screen(intLoc) = sum(move_resp(vecStimIdx == intLoc));

    
end
AUCmatAvgRespAll(:,:,1) = AUCmatAvgResp;
speed_prob_all(:,:,1) = init_prob_screen;
speed_resp_all(:,:,1) = speed_resp_screen;


%% plot trace data

traceLim = median(matAvgResp(:,before:before + after),"all")+2*std(matAvgResp(:,before:before + after),0,"all");


% figure;
% h = imagesc(matAvgResp(:, 1:before+after + 0.5*sr)); % 1 seconds after trial offset
% set(h, 'Interpolation', 'nearest');  % Prevent smoothing
% 
% xline(before + 0.5, '--w', 'LineWidth', 1.5);          % Stim onset
% xline(before + after+0.5, '--w', 'LineWidth', 1.5);  % Stim offset
% % xticks(-before+0.5:6:after+0.5); 
% % xticklabels(labelsX)
% xlabel('Time (frames)');
% ylabel('Stimulus Position (X,Y)');
% if cBarLim
%     clim([-traceLim traceLim]);
% end
% colormap('parula');  
% colorbar;
% title('Z score by stim position');
% box off;

%% plot AUC data
%interpolate
vecX_pix_interp = linspace(vecX_pix(1),vecX_pix(end),16);
vecY_pix_interp = linspace(vecY_pix(1),vecY_pix(end),9);

%get colormap(s)
cellColorMaps = RH_ColorMaps; % or colormap parula

aucLim = median(AUCmatAvgRespAll,"all")+2*std(AUCmatAvgRespAll, 0, "all");

set(0,'DefaultFigureWindowStyle','docked')

matAvgRespAll_interp = AUCmatAvgRespAll(:,:,1);
figure; hold on;
xline(before+0.5, '--w', 'Linewidth', 1.5)
title([animal, 'Ch: ' num2str(ch)]);
imagesc(vecX_pix_interp,vecY_pix_interp,matAvgRespAll_interp);
set(gca, 'YDir','reverse');
if cBarLim
    clim([-aucLim aucLim]);
end
colormap('parula');
% colormap(cellColorMaps{2});
cb=colorbar;
cb.Label.String='AUC of Z-score or df/F';
axis image;
fixfig;

%% plot initiation data

speed_prob_all_interp = speed_prob_all(:,:,1);
figure; hold on;
xline(before+0.5, '--w', 'Linewidth', 1.5)
title([animal, 'Ch: ' num2str(ch)]);
imagesc(vecX_pix_interp,vecY_pix_interp,speed_prob_all_interp);
set(gca, 'YDir','reverse');
if cBarLim
    clim([-aucLim aucLim]);
end
colormap('parula');
% colormap(cellColorMaps{2});
cb=colorbar;
cb.Label.String='movement probability';
axis image;
fixfig;

%% plot increase data

speed_resp_all_interp = speed_resp_all(:,:,1);
figure; hold on;
xline(before+0.5, '--w', 'Linewidth', 1.5)
title([animal, 'Ch: ' num2str(ch)]);
imagesc(vecX_pix_interp,vecY_pix_interp,speed_resp_all_interp);
set(gca, 'YDir','reverse');
if cBarLim
    clim([-aucLim aucLim]);
end
colormap('parula');
% colormap(cellColorMaps{2});
cb=colorbar;
cb.Label.String='movement decrease';
axis image;
fixfig;


end